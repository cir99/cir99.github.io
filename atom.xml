<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长路</title>
  
  <subtitle>归去，也无风雨也无晴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cir99.github.io/"/>
  <updated>2018-02-25T02:56:17.676Z</updated>
  <id>https://cir99.github.io/</id>
  
  <author>
    <name>coach chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法图解第10章笔记</title>
    <link href="https://cir99.github.io/2018/02/25/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC10%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://cir99.github.io/2018/02/25/算法图解第10章笔记/</id>
    <published>2018-02-25T02:54:38.000Z</published>
    <updated>2018-02-25T02:56:17.676Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： 笔记 python 简单算法</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26125533&auto=0&height=66"></iframe><h2 id="K最邻算法-KNN算法）"><a href="#K最邻算法-KNN算法）" class="headerlink" title="K最邻算法(KNN算法）"></a>K最邻算法(KNN算法）</h2><a id="more"></a><ul><li>前言</li></ul><p>我第一次见到此算法(k-nearest neighbour)，是在《机器学习实战》中，也是用python实现的。那时看的比较匆忙，应该不怎么理解，这次再深入理解吧！算法图解这本书已经接近尾声了，过一阵子我会好好写《机器学习实战》的笔记。（难度很大，会参考其他大神的笔记，更新会慢很多）。<br>KNN算法只要应用在分类。</p><ul><li>原理简述和举例<br>首先，明确分类的依据是事物的特征。而特征可分为能用数字表示和不能用数字表示两类。例如，年龄，长度和体重可以用数字表示，但像形状，气味等感官特征就难以用数字表示，这时我们可以人为规定数字给相应的特征。<br>然后将这些表示在坐标系中表示出来（人类的思维）。如下图，就是两个特征坐标系。<br>举例说明：<br>你有三个水果，想判断它们分别是柚子还是橙子。这时，你会想到从两个特征来分类，一是个头大小，二是红的程度。（书本假定，柚子比橙子更红更大），然后用欧式距离公式计算该点与其他点的距离。这个例子中，K选择为1，即选择最近点来衡量该点是柚子还是橙子。<br><img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1foshwvmf6zj20a708ut9a.jpg" alt=""></li></ul><p>  注意：这里有两个特征所以为平面坐标系，当超过三个特征就难以用图形（人类难以理解）表示出来，不过距离公式还是相同。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>  算法图解只是简单介绍KNN算法，关于此算法的优缺点，K的选择等会在我写《机器学习实战》笔记更详细介绍。总的来说，这算法还是挺有趣的，而且很实用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： 笔记 python 简单算法&lt;/p&gt;
&lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=26125533&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;K最邻算法-KNN算法）&quot;&gt;&lt;a href=&quot;#K最邻算法-KNN算法）&quot; class=&quot;headerlink&quot; title=&quot;K最邻算法(KNN算法）&quot;&gt;&lt;/a&gt;K最邻算法(KNN算法）&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法图解第9章笔记</title>
    <link href="https://cir99.github.io/2018/02/25/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC9%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://cir99.github.io/2018/02/25/算法图解第9章笔记/</id>
    <published>2018-02-25T01:25:19.000Z</published>
    <updated>2018-02-25T01:52:30.796Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=139707&auto=0&height=66"></iframe><p>标签（空格分隔）： 简单算法 笔记 python</p><hr><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划原理是先解决子问题，再逐步解决大问题。<br>简单例子（背包问题）：你是小偷，现有一个容量为4磅的背包。商店有三种商品为：$3000的音响重为4磅；$2000的笔记本电脑重为3磅，$1500的吉他重为1磅。你怎样偷窃才能获利最多？</p><a id="more"></a><p>最简单的办法：遍历所有可能组合，找到最值钱的组合。可惜存在一个巨大的缺点，算法运行时间为O(2^n),慢如蜗牛。<br>合理的方法（动态归划）：原理是先解决小背包（子背包）问题，再逐步解决原来的问题。通过迭代当前容量最大价值解决问题，如下图：</p><p><img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1fosdv3rnqyj20dv094ac2.jpg" alt=""></p><p>  局限：但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。举例，有限时间在英国各地游览和中途去法国各景点游览。</p><p> 启示：</p><ul><li>动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必 须在背包容量给定的情况下，偷到价值最高的商品。</li><li><p>在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。</p></li><li><p>每种动态规划解决方案都涉及网格。</p></li><li><p>单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。</p></li><li><p>每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。</p></li></ul><h2 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h2><p>当你不小心hish，输入法怎样会提供相近的单词fish作为参考，而不是vista？这是就要计算最长公共子串(是网格中最大的数字)，如下图：<br><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1fosetnqxzwj20gr0c9q5e.jpg" width="350" height="200"><br><img src="http://wx3.sinaimg.cn/mw690/7e99332fgy1fosetv348fj20az09wjsz.jpg" width="350" height="200"><br>由此，输入法判断的是fish作为参考。<br><strong>具体代码实现，以后再补充。</strong></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>假设你不小心输入了fosh，原本想输入的是fish还是fort呢?<br>可以看出，两个单词和fosh的最长公共子串都为2，这是就要判断最长公共子序列，计算公式如下图：<br><img src="http://wx2.sinaimg.cn/mw690/7e99332fgy1fosfbrszfmj20hz0apmzj.jpg" width="450" height="300"><br><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1fosfc9lixnj20hj07l0uv.jpg" width="450" height="300"><br>所以输入法判断想输入的是fish。<br><strong>具体代码，以后补充。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1fosfhdetdsj20ng08itbi.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=139707&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;标签（空格分隔）： 简单算法 笔记 python&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划原理是先解决子问题，再逐步解决大问题。&lt;br&gt;简单例子（背包问题）：你是小偷，现有一个容量为4磅的背包。商店有三种商品为：$3000的音响重为4磅；$2000的笔记本电脑重为3磅，$1500的吉他重为1磅。你怎样偷窃才能获利最多？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法图解第8章笔记</title>
    <link href="https://cir99.github.io/2018/02/25/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC8%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://cir99.github.io/2018/02/25/算法图解第8章笔记/</id>
    <published>2018-02-24T16:42:28.000Z</published>
    <updated>2018-02-24T16:48:23.724Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： 简单算法 笔记 python</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=477841196&auto=0&height=66"></iframe><h2 id="贪婪算法思想："><a href="#贪婪算法思想：" class="headerlink" title="贪婪算法思想："></a>贪婪算法思想：</h2><p>每步都选择局部最优解，最终得到的就是全局最优解。<br><a id="more"></a></p><h2 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h2><p>假如你办了个广播节目。要让全美50个州的听众都收听到，为了支付较低的费用，你决定在尽可能少的广播台播出。<br>每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。</p><p> <img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1forpkc9kdbj20ab0c2jt7.jpg" width="200" height="100"><br> 求完美解的时间复杂度O(2^n),会导致运行时间太长，不符合实际应用。<br> 我们可以采用近似算法，贪婪算法解决。</p><p> 衡量一种近似算法的好坏只要有两种标准：</p><ol><li>运行速度；</li><li>得到的近似解与最优解的接近程度。</li></ol><h2 id="运用贪婪算法解决集合覆盖问题"><a href="#运用贪婪算法解决集合覆盖问题" class="headerlink" title="运用贪婪算法解决集合覆盖问题"></a>运用贪婪算法解决集合覆盖问题</h2><p>假设有如下的州：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传入一个州数组并转换为集合set，表示还需要覆盖州</span></span><br><span class="line">states_needed = set([<span class="string">"mt"</span>, <span class="string">"wa"</span>, <span class="string">"or"</span>, <span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>, <span class="string">"ca"</span>, <span class="string">"az"</span>])  </span><br><span class="line"><span class="comment">#用散列表表示可选电台</span></span><br><span class="line">stations = &#123;&#125;</span><br><span class="line">stations[<span class="string">"kone"</span>] = set([<span class="string">"id"</span>, <span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"ktwo"</span>] = set([<span class="string">"wa"</span>, <span class="string">"id"</span>, <span class="string">"mt"</span>])</span><br><span class="line">stations[<span class="string">"kthree"</span>] = set([<span class="string">"or"</span>, <span class="string">"nv"</span>, <span class="string">"ca"</span>])</span><br><span class="line">stations[<span class="string">"kfour"</span>] = set([<span class="string">"nv"</span>, <span class="string">"ut"</span>])</span><br><span class="line">stations[<span class="string">"kfive"</span>] = set([<span class="string">"ca"</span>, <span class="string">"az"</span>])</span><br><span class="line"><span class="comment">#存储最终选择的电台</span></span><br><span class="line">final_stations = set()</span><br><span class="line"><span class="comment">#选择最佳的未选择电台</span></span><br><span class="line"><span class="comment">#循环直至覆盖完</span></span><br><span class="line"><span class="keyword">while</span> states_needed:</span><br><span class="line">  best_station = <span class="keyword">None</span></span><br><span class="line"><span class="comment">#包含该电台覆盖的所有未覆盖的州</span></span><br><span class="line">  states_covered = set()</span><br><span class="line">  <span class="comment">#第一个参数返回散列表的键，第二个参数返回散列表的值</span></span><br><span class="line">  <span class="keyword">for</span> station, states_for_station <span class="keyword">in</span> stations.items():</span><br><span class="line">  <span class="comment">#计算交集</span></span><br><span class="line">  <span class="comment">#它包含当前电台覆盖的 一系列还未覆盖的州</span></span><br><span class="line">    covered = states_needed &amp; states_for_station</span><br><span class="line">  <span class="comment">#判断最佳电台</span></span><br><span class="line">    <span class="keyword">if</span> len(covered) &gt; len(states_covered):   </span><br><span class="line">      best_station = station   </span><br><span class="line">      states_covered = covered</span><br><span class="line"></span><br><span class="line">  states_needed -= states_covered   </span><br><span class="line">  final_stations.add(best_station)  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">print</span> final_stations</span><br></pre></td></tr></table></figure></p><p>set:<br>集合的特点是去重，在前面的博文有提过用JS的Set对象，进行去重。我猜测JS应该借鉴了python吧。<br>集合运算：|（并集）,&amp;（交集）, -（差集）<br> item():<br> Python 字典 items() 方法以列表返回可遍历的(键, 值) 元组数组。</p><h2 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h2><p> 旅行商问题：游览n个城市（不重复），可能的路径有多少条？<br> 答案是：n!。当要求精确求出最短路径时，就需遍历n!条路径（当n=10时，n!= 3 628 800）。可以看出，当n越大，路径就急速增加，所以求出精确解也是不符实际。所以，只能近似求解。<br> 上述的旅行商问题和集合覆盖问题同属于NP完全问题，对于此类问题较为合适的方法是近似求解，而不是求完美解。<br> 这样就诞生一个新的问题：什么问题才是NP完全问题？<br> NP完全问题特征：</p><ul><li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li><li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li><li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li><li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li></ul><p>idea:</p><ul><li>贪婪算法与内存管理</li><li>没点数学思维，快递我都送不好，快递小哥辛苦了！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： 简单算法 笔记 python&lt;/p&gt;
&lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=477841196&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;贪婪算法思想：&quot;&gt;&lt;a href=&quot;#贪婪算法思想：&quot; class=&quot;headerlink&quot; title=&quot;贪婪算法思想：&quot;&gt;&lt;/a&gt;贪婪算法思想：&lt;/h2&gt;&lt;p&gt;每步都选择局部最优解，最终得到的就是全局最优解。&lt;br&gt;
    
    </summary>
    
    
      <category term="简单算法 笔记 python" scheme="https://cir99.github.io/tags/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B0-python/"/>
    
  </entry>
  
  <entry>
    <title>算法图解第7章笔记</title>
    <link href="https://cir99.github.io/2018/02/24/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://cir99.github.io/2018/02/24/算法图解第7章笔记/</id>
    <published>2018-02-24T08:42:50.000Z</published>
    <updated>2018-02-24T16:48:42.877Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： 笔记  简单算法 python</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=18861490&auto=0&height=66"></iframe><h2 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h2><a id="more"></a><p><img src="http://wx2.sinaimg.cn/mw690/7e99332fgy1forfh01tuaj20qo05m75w.jpg" alt=""></p><p>  要计算非加权图中的最短路径，可使用广度优先搜索。要计算 加权图中的最短路径，可使用狄克斯特拉算法。<br>  <img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1forfkfc3hyj20i003nglz.jpg" alt=""></p><p>  实例分析：<br>  <img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1forfvybf47j20i609wq5l.jpg" alt=""></p><p>  在这张图上，你怎样用最少的钱将乐谱交换到钢琴？这时就要使用狄克斯特拉算法。</p><ol><li>找出最便宜的节点，即可在最短时间内前往的节点。</li><li>对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。</li><li>重复这个过程，直到对图中的每个节点都这样做了。</li><li>计算最终路径。</li></ol><p>算法执行后更新的开销如下表：<br><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1forg3ded18j20j3066gnw.jpg" alt=""></p><p>  从此，可以看出最低花销是35，如何将交换路线确定？只需从钢琴出发，不断求父节点直到乐谱为止就可以确定了。<br>  补充：此算法不适用于负加权的图，若有负加权，应采用贝尔曼-福得算法（Bellman-Ford algorithm）。<em>以后我会补充说明</em></p><h2 id="代码实现狄克斯特拉算法"><a href="#代码实现狄克斯特拉算法" class="headerlink" title="代码实现狄克斯特拉算法"></a>代码实现狄克斯特拉算法</h2><p><img src="http://wx2.sinaimg.cn/mw690/7e99332fgy1fork8muaauj209d04x0t3.jpg" alt=""></p><p>  以上图为例，进行实现。<br>  准备：<br>  要构建两个散列表（costs&amp;parents)和一个图（graph)。</p><ul><li><p>costs散列表<br>用来存储每个节点的开销，算法代码运行后会更新起点到该节点的<strong>最低</strong>花销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设到达终点的花销为无穷大</span></span><br><span class="line">infinity=float(<span class="string">"inf"</span>)</span><br><span class="line"><span class="comment">#使用python的字典</span></span><br><span class="line">costs=&#123;&#125;</span><br><span class="line">costs[<span class="string">"a"</span>]=<span class="number">6</span></span><br><span class="line">costs[<span class="string">"b"</span>]=<span class="number">2</span></span><br><span class="line">cost[<span class="string">"fin"</span>]=infinity</span><br></pre></td></tr></table></figure></li><li><p>parents散列表<br>存储各节点的父节点的散列表，算法代码运行后会更新起点到终点花销<strong>最低</strong>的路线（从终点不停找父节点直至起点）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parents=&#123;&#125;</span><br><span class="line">parents[<span class="string">"a"</span>]=<span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"b"</span>]=<span class="string">"start"</span></span><br><span class="line"><span class="comment">#将终点节点的父节点设为空</span></span><br><span class="line">parents[<span class="string">"fin"</span>]=<span class="keyword">None</span></span><br></pre></td></tr></table></figure></li><li><p>graph图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph=&#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>]=&#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"a"</span>]=<span class="number">6</span></span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"b"</span>]=<span class="number">2</span></span><br><span class="line">graph[<span class="string">"a"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"a"</span>][<span class="string">"fin"</span>] = <span class="number">1</span></span><br><span class="line">graph[<span class="string">"b"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"a"</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"fin"</span>] = <span class="number">5</span></span><br><span class="line">graph[<span class="string">"fin"</span>] = &#123;&#125;</span><br></pre></td></tr></table></figure><p>实现：<br><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1forlrazofyj20uq0b5n29.jpg" alt=""></p></li></ul><p><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1forlwq95zzj20qu06ljt2.jpg" alt=""></p><p>  详细部分和思路请浏览第7章后半部分。</p><p>  小结：</p><ul><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： 笔记  简单算法 python&lt;/p&gt;
&lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=18861490&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;狄克斯特拉算法&quot;&gt;&lt;a href=&quot;#狄克斯特拉算法&quot; class=&quot;headerlink&quot; title=&quot;狄克斯特拉算法&quot;&gt;&lt;/a&gt;狄克斯特拉算法&lt;/h2&gt;
    
    </summary>
    
    
      <category term="简单算法 笔记 python" scheme="https://cir99.github.io/tags/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B0-python/"/>
    
  </entry>
  
  <entry>
    <title>算法图解第6章笔记</title>
    <link href="https://cir99.github.io/2018/02/24/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%AC6%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://cir99.github.io/2018/02/24/算法图解第6章笔记/</id>
    <published>2018-02-24T04:14:17.000Z</published>
    <updated>2018-02-24T16:49:26.781Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： 笔记 基础算法 python</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=19563214&auto=0&height=66"></iframe><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。<br><img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1forcx26fr3j20gn0asq4u.jpg" alt=""><br>简单图的python表示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line">graph[<span class="string">"you"</span>] = [<span class="string">"alice"</span>, <span class="string">"bob"</span>, <span class="string">"claire"</span>]</span><br><span class="line">graph[<span class="string">"bob"</span>] = [<span class="string">"anuj"</span>, <span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"alice"</span>] = [<span class="string">"peggy"</span>]</span><br><span class="line">graph[<span class="string">"claire"</span>] = [<span class="string">"thom"</span>, <span class="string">"jonny"</span>]</span><br><span class="line">graph[<span class="string">"anuj"</span>] = []</span><br><span class="line">graph[<span class="string">"peggy"</span>] = []</span><br><span class="line">graph[<span class="string">"thom"</span>] = []</span><br><span class="line">graph[<span class="string">"jonny"</span>] = []</span><br></pre></td></tr></table></figure></p><p>补充：散列表是无序的，因此添加键—值对的顺序无关紧要。</p><p>  图分为有向图和无向图（等价）。</p><h2 id="广度优先搜索算法示例"><a href="#广度优先搜索算法示例" class="headerlink" title="广度优先搜索算法示例"></a>广度优先搜索算法示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="comment">#创建一个双端队列</span></span><br><span class="line">  search_queue = deque()</span><br><span class="line"><span class="comment">#将你的邻居都加入到这个搜索队列中</span></span><br><span class="line">  search_queue += graph[<span class="string">"you"</span>]</span><br><span class="line">  searched = []</span><br><span class="line">  <span class="keyword">while</span> search_queue:</span><br><span class="line">    person = search_queue.popleft()</span><br><span class="line">  <span class="comment">#当此人不被标记是才判断</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> person <span class="keyword">in</span> searched:</span><br><span class="line">      <span class="keyword">if</span> person_is_seller(person):</span><br><span class="line">        <span class="keyword">print</span> person + <span class="string">" is a mango seller!"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        search_queue += graph[person] s</span><br><span class="line">        earched.append(person)</span><br><span class="line">  <span class="keyword">return</span> false</span><br><span class="line"></span><br><span class="line"><span class="comment">#简单的判断函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person_is_seller</span><span class="params">(name)</span>:</span>     </span><br><span class="line">  <span class="keyword">return</span> name[<span class="number">-1</span>] == <span class="string">'m'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">search(<span class="string">"you"</span>)</span><br></pre></td></tr></table></figure><p>广度优先搜索的运行时间为 O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。</p><p><img src="http://wx4.sinaimg.cn/mw690/7e99332fgy1foretgp92aj20em09vq4q.jpg" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： 笔记 基础算法 python&lt;/p&gt;
&lt;hr&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=19563214&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
    
      <category term="简单算法 笔记 python" scheme="https://cir99.github.io/tags/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B0-python/"/>
    
  </entry>
  
  <entry>
    <title>个人总结的几种数组去重方法</title>
    <link href="https://cir99.github.io/2018/02/24/array/"/>
    <id>https://cir99.github.io/2018/02/24/array/</id>
    <published>2018-02-24T02:00:41.000Z</published>
    <updated>2018-02-24T02:30:01.379Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： 数组 JavaScript</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;博客第一篇技术文章（非常基础,因为我太菜了）总结了几种不同方法的数组去重方法。文章不是很全面，还有例如利用对象唯一性去重等方法，可是我觉得太麻烦和有些缺点就没有收集了。</p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=461074907&auto=0&height=66"></iframe><br><a id="more"></a></p><h2 id="双循环"><a href="#双循环" class="headerlink" title="双循环"></a>双循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//对于原数组的每个元素遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">          <span class="comment">//对选定元素跟后面的各个元素遍历比较</span></span><br><span class="line">          <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">            <span class="comment">// 遇到重复元素就跳过</span></span><br><span class="line">            j = ++i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将不重复的元素添加到result数组</span></span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：这就是基本的双循环去重。注释已经较好的说明原理，注意的就是j=++i;相当于j = j+1; i = i+1;。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="comment">//先将原数组排序，再比较</span></span><br><span class="line">    arr.sort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] != arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">//元素跟后一个元素比较，不同则添加</span></span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>说明：由于排序的缘故，元素只需跟后一个元素比较就可以了，该方法效率偏低，但思路很清晰。</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//在result中没找到的元素，就进行添加</span></span><br><span class="line">          result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：indexOf()是es5的语法，对它不熟悉的话可以点击下面的链接浏览一下。去重的原理是indexOf()会对没找到的元素，返回-1，此时添加此元素即可去重。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf</a></p><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!newArr.includes(item)) &#123;</span><br><span class="line">          result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：原理跟上面的indexOf()一样，值得注意的是forEach()是es5语法，ie6-8是不能用的，mdn上有兼容的方法。forEach()的作用是遍历数组元素，对它们执行相同的方法。includes()方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。下面链接介绍它们的用法。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes</a></p><h2 id="Map（es6"><a href="#Map（es6" class="headerlink" title="Map（es6)"></a>Map（es6)</h2><p>对于es6不熟悉的人（我）可以看看阮一峰大神的著作，里面就有详细的Map和Set的说明<br><a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/set-map</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">      <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !res.has(a) &amp;&amp; res.set(a, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unique0</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      <span class="keyword">var</span> len = arr.length;</span><br><span class="line">      <span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tmp.get(arr[i])) &#123;</span><br><span class="line">          tmp.set(arr[i], <span class="number">1</span>);</span><br><span class="line">          result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说明：关于这部分我还不是很熟悉，待我研究后再来补充吧。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p><h2 id="Set（es6"><a href="#Set（es6" class="headerlink" title="Set（es6)"></a>Set（es6)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="comment">//使用Array.from()将Set对象转化为数组</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓展运算符(…)内部使用for...of循环,for...of支持数组，和类数组对象</span></span><br><span class="line"><span class="keyword">let</span> result=[...new <span class="built_in">Set</span>(arr)];</span><br></pre></td></tr></table></figure><p>说明：你没看错，去重就这么简单，具体的原理我再来补充吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： 数组 JavaScript&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;博客第一篇技术文章（非常基础,因为我太菜了）总结了几种不同方法的数组去重方法。文章不是很全面，还有例如利用对象唯一性去重等方法，可是我觉得太麻烦和有些缺点就没有收集了。&lt;/p&gt;
&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=461074907&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>神海4系列通关感想</title>
    <link href="https://cir99.github.io/2018/02/23/title/"/>
    <id>https://cir99.github.io/2018/02/23/title/</id>
    <published>2018-02-23T15:48:03.000Z</published>
    <updated>2018-02-24T02:29:50.284Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>标签： PS4   神秘海域 失落的遗产</p><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437480685&auto=0&height=66"></iframe><p>&emsp;&emsp;第一篇文章写一下年后通关的神海4DLC吧，用来熟悉一下Markdown语法和用hexo搭建的博客吧。对于这个博客还有很多不熟悉的地方，样式也是照搬别人家的，慢慢的继续研究吧，欲速而不达。对于搭建自己的blog，虽然没有绑定域名，还是很兴奋的算是实现一个很酷的想法吧。<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&emsp;&emsp;首先，自己对神秘海域4是有特殊情感的，它是我第一款PS4游戏，第一个通关的PS4游戏，第一个获得白金奖杯的游戏。<br><img src="http://wx2.sinaimg.cn/mw690/7e99332fgy1foqoa9v6vsj21hc0u0n1p.jpg" alt="神秘海域4"></p><p><img src="http://wx3.sinaimg.cn/mw690/7e99332fgy1foqo8xcz3kj21hc0u0doh.jpg" alt="神秘海域4"></p><p>  &emsp;&emsp;至今还记得，奈特在嵩山峻岭中飞檐走壁，在枪林弹雨中肉搏杂兵（我是近战莽夫流，哈哈），在长草中悄无声息的暗杀敌人，在沉船中和Rafe比剑，与妻子在家打电动，与山姆在碧海中遨游。最后还有在白金路上的苦苦挣扎。<br>  <img src="http://wx1.sinaimg.cn/mw690/7e99332fgy1foqoaei2pkj21hc0u0tgn.jpg" alt="此处输入图片的描述"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>  &emsp;&emsp;在这里先赞一下这个DLC做的不错，长度不是太长，但玩的我畅快淋漓，热血沸腾。这次故事发生在印度，但其文化背景我通关后还是弄不明白什么湿婆啊，象神啊。不过还是给我带来耳目一新的感觉，场景细节塑造的太好了（比神海4又进步了），看到那些雕像和壁画真的栩栩如生。战斗方面，敌人好像没本篇的强大，但是地形实在太恶劣，一会是悬崖，一会是四通八达的山洞（最后一章死的心态有点爆炸）。结尾的追逐战高潮迭起，狠揍那个反抗军首领解气，还有山姆宝宝的搞笑担当。虽然，知道神秘海域系列就此完结，但没有一丝遗憾，反而有一种由衷的满足感。在我的游戏史，可能忘不了这群欢乐的宝藏盗贼吧。希望，将来顽皮狗在最后生还者2给我更大的惊喜吧！<br>  <img src="http://wx2.sinaimg.cn/mw690/7e99332fgy1foqo857k9pj21hc0u0dsk.jpg" alt="此处输入图片的描述"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>&emsp;&emsp;未来，我会勤奋的更博（主要总结自己学习的心得）好好装扮这个blog，还要接触更多的技术。就说这么多吧，bye!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： PS4   神秘海域 失落的遗产&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=437480685&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;第一篇文章写一下年后通关的神海4DLC吧，用来熟悉一下Markdown语法和用hexo搭建的博客吧。对于这个博客还有很多不熟悉的地方，样式也是照搬别人家的，慢慢的继续研究吧，欲速而不达。对于搭建自己的blog，虽然没有绑定域名，还是很兴奋的算是实现一个很酷的想法吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cir99.github.io/2018/02/23/hello-world/"/>
    <id>https://cir99.github.io/2018/02/23/hello-world/</id>
    <published>2018-02-23T01:57:23.200Z</published>
    <updated>2018-02-24T02:22:30.923Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27979418&auto=0&height=66"></iframe><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a> </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=27979418&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
